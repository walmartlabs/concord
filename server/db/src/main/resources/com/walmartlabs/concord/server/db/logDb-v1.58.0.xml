<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.3.xsd">

    <changeSet id="1580000" author="ibodrov@gmail.com">
        <!--
            A hacky way to convert timestamp to timestamptz without rewriting the data.

            Assuming the current data is in UTC, we can change all "timestamp" columns
            and indices to "timestamp with time zone" just by updating the column's "atttypid".

            Requires SUPERUSER privileges.
        -->
        <createProcedure dbms="postgresql">
            create or replace function ts_to_tstz(t text)
                returns bool as $$
            declare
                v_cnt numeric;
            begin
                v_cnt := 0;

                update pg_attribute
                    set atttypid = 'timestamp with time zone'::regtype
                from pg_class
                where attrelid = pg_class.oid
                    and relnamespace = current_schema()::regnamespace
                    and atttypid = 'timestamp'::regtype
                    and relname ilike t;

                get diagnostics v_cnt = row_count;
                if v_cnt = 0 then
                    raise warning 'Relation not found (or is already converted): %', t;
                end if;

                update pg_index
                    set indclass = array_to_string(array_replace(indclass::oid[], 3128::oid, 3127::oid), ' ')::oidvector
                from pg_class
                where indrelid = pg_class.oid
                    and relnamespace = current_schema()::regnamespace
                    and indclass::oid[] @> ARRAY[3128::oid]
                    and relname ilike t;

                return v_cnt > 0;
            end;
            $$ language plpgsql
        </createProcedure>
    </changeSet>

    <!-- tables that might be partitioned -->

    <!-- PROCESS_LOG_DATA -->
    <changeSet id="1580230" author="ibodrov@gmail.com">
        <preConditions onFail="MARK_RAN">
            <changeLogPropertyDefined property="superuserAvailable" value="true"/>
        </preConditions>

        <sql>
            select ts_to_tstz('process_log_data%')
        </sql>
    </changeSet>

    <changeSet id="1580230-a" author="ibodrov@gmail.com">
        <preConditions onFail="MARK_RAN">
            <changeLogPropertyDefined property="superuserAvailable" value="false"/>
        </preConditions>

        <sql>
            alter table PROCESS_LOG_DATA
                alter column INSTANCE_CREATED_AT type timestamptz using INSTANCE_CREATED_AT at time zone 'UTC'
        </sql>
    </changeSet>

    <!-- PROCESS_LOG_SEGMENTS -->
    <changeSet id="1580240" author="ibodrov@gmail.com">
        <preConditions onFail="MARK_RAN">
            <changeLogPropertyDefined property="superuserAvailable" value="true"/>
        </preConditions>

        <sql>
            select ts_to_tstz('process_log_segments%')
        </sql>
    </changeSet>

    <changeSet id="1580240-a" author="ibodrov@gmail.com">
        <preConditions onFail="MARK_RAN">
            <changeLogPropertyDefined property="superuserAvailable" value="false"/>
        </preConditions>

        <sql>
            alter table PROCESS_LOG_SEGMENTS
                alter column INSTANCE_CREATED_AT type timestamptz using INSTANCE_CREATED_AT at time zone 'UTC',
                alter column SEGMENT_TS type timestamptz using SEGMENT_TS at time zone 'UTC'
        </sql>
    </changeSet>

    <!-- functions and procedures -->

    <changeSet id="1580500" author="ibodrov@gmail.com">
        <createProcedure dbms="postgresql">
            create or replace function PROCESS_LOG_DATA_SEGMENT_NEXT_RANGE(P_INSTANCE_ID uuid, P_CREATED_AT timestamptz, P_SEGMENT_ID bigint, P_DATA_LEN int)
                returns int4range as $$
            declare
                R_START int;
            begin
                select coalesce(max(upper(SEGMENT_RANGE)), 0) into R_START
                from PROCESS_LOG_DATA
                where
                INSTANCE_ID = P_INSTANCE_ID and INSTANCE_CREATED_AT = P_CREATED_AT and SEGMENT_ID = P_SEGMENT_ID;

                if R_START is null then
                    R_START := 0;
                end if;

                return int4range(R_START, R_START + P_DATA_LEN);
            end;
            $$ language plpgsql;
        </createProcedure>

        <createProcedure dbms="postgresql">
            create or replace function PROCESS_LOG_DATA_NEXT_RANGE(P_INSTANCE_ID uuid, P_CREATED_AT timestamptz, P_DATA_LEN int)
                returns int4range as $$
            declare
                R_START int;
            begin
                select coalesce(max(upper(LOG_RANGE)), 0) into R_START
                from PROCESS_LOG_DATA
                where
                INSTANCE_ID = P_INSTANCE_ID and INSTANCE_CREATED_AT = P_CREATED_AT;

                if R_START is null then
                    R_START := 0;
                end if;

                return int4range(R_START, R_START + P_DATA_LEN);
            end;
            $$ language plpgsql;
        </createProcedure>
    </changeSet>

    <changeSet id="1580510" author="ibodrov@gmail.com">
        <createProcedure dbms="postgresql">
            create or replace function PROCESS_LOG_DATA_SEGMENT_LAST_N_BYTES(P_INSTANCE_ID uuid, P_CREATED_AT timestamptz, P_SEGMENT_ID bigint, P_DATA_LEN int)
                returns int4range as $$
            declare
                R_START int;
            begin
                select coalesce(max(upper(SEGMENT_RANGE)), 0) into R_START
                from PROCESS_LOG_DATA
                where
                INSTANCE_ID = P_INSTANCE_ID and INSTANCE_CREATED_AT = P_CREATED_AT and SEGMENT_ID = P_SEGMENT_ID;

                if R_START is null then
                R_START := 0;
                end if;

                return int4range(R_START - P_DATA_LEN, R_START);
            end;
            $$ language plpgsql;
        </createProcedure>
    </changeSet>

    <changeSet id="1580520" author="ibodrov@gmail.com">
        <createProcedure dbms="postgresql">
            create or replace function PROCESS_LOG_DATA_LAST_N_BYTES(P_INSTANCE_ID uuid, P_CREATED_AT timestamptz, P_DATA_LEN int)
                returns int4range as $$
            declare
                R_START int;
            begin
                select coalesce(max(upper(LOG_RANGE)), 0) into R_START
                from PROCESS_LOG_DATA
                where
                INSTANCE_ID = P_INSTANCE_ID and INSTANCE_CREATED_AT = P_CREATED_AT;

                if R_START is null then
                    R_START := 0;
                end if;

                return int4range(R_START - P_DATA_LEN, R_START);
            end;
            $$ language plpgsql;
        </createProcedure>
    </changeSet>
</databaseChangeLog>
